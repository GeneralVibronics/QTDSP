\section{Testing}

The demodulation algorithm was tested by coding the algorithm in C (as a console
application) and instrumenting it to display variables,
save arrays to files, and benchmark the various stages.
Double numbers (64-bit IEEE754 format) sacrifice speed for simplicity.
On a fast Core-i7 PC, the algorithm correlates 20 frames in 40 msec.
Each of these frames processes 64 new input points with a 1K FFT.
Allowing 2ms per 64 points amounts to 32K SPS of input which, when $R=-0.5$,
is 8K SPS of output.

A decent speedup (x3 to x5) could be had with better coding. 
This would bring the C version running on a single desktop PC core on par with
a single FPGA-based core, although the latter itself can have its FFT improved
to provide a 2:1 speed advantage over the desktop core.
In other words, a desktop PC is fine for exploring applications of the algorithm.
A many-core ASIC, on the other hand, would be a better option for serious data
mining.

\subsection{EEG data}

An ideal test for the algorithm is EEG data taken from public data sets
from sites such as http://www.bbci.de/.
The EEG data uses the General Data Format for biomedical signals (GDF), which
can be parsed by the open source BioSig C/C++ library.
http://kdd.ics.uci.edu/databases/eeg/eeg.html supplies data in an easier to
parse format.

The demodulation algorithm looks at the signal bandwidth between about
$F_S/5$ and $F_S/2$.
Many data sets have a region of interest far below the sample rate.
Decimation is typically used to lower the sample rate to bring it to the
desired region of interest. 
Decimation by a factor of M usually involves low-pass filtering the signal
and taking every Mth data point as output.
A more sloppy method is to simply sum each set of M input points and ignore
the aliasing effects since those will be smeared across the noise floor.

A graphic display can have a waterfall representation of the waveform along
with cue markers. Once processed, the graphic image can be panned or scrolled
as appropriate within the app or output as a video file for playback.


